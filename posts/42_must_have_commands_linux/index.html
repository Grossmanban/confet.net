<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>42 команды Linux которые вы должны знать :: Terminal</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="о всех операционных системах, в том числе и в Linux, термин &lsquo;команда&rsquo; означает либо утилиту командной строки, либо определённую возможность, встроенную в командную оболочку системы. Тем не менее, для самих пользователей это различие не имеет особого значения. В конце концов, и те и другие команды терминала Linux вызываются одинаково. Вы вводите слово в вашем эмуляторе терминала и получаете результат выполнения команды.
Я уже писал о командах терминала Linux, но тогда затронул лишь несколько самых интересных, самых полезных команд, рассчитывая на то, что пользователь уже достаточно знаком с возможностями терминала. Но нужно сделать ещё одну статью, рассчитанную на новичков, тех, кто только делает свои первые шаги в освоении Linux.
" />
<meta name="keywords" content=", " />

  <meta name="robots" content="noodp" />

<link rel="canonical" href="/posts/42_must_have_commands_linux/" />





  
  <link rel="stylesheet" href="/css/buttons.min.2bc533403a27dfe0e93105a92502b42ce4587e2e4a87d9f7d349e51e16e09478.css">

  
  <link rel="stylesheet" href="/css/code.min.9db603e0d861c0df7a77b184868b72f50462a1d64eda830d14b527b8c22d1fac.css">

  
  <link rel="stylesheet" href="/css/fonts.min.90c955c31dd7c0e05aae3d4f583d4d8a2af799d69c961337eaf2a825063a55dd.css">

  
  <link rel="stylesheet" href="/css/footer.min.2e3eb191baee58dd05a9f0104ac1fab0827bca7c64dafe0b2579f934c33a1d69.css">

  
  <link rel="stylesheet" href="/css/gist.min.a751e8b0abe1ba8bc53ced52a38b19d8950fe78ca29454ea8c2595cf26aad5c0.css">

  
  <link rel="stylesheet" href="/css/header.min.b6fb4423cf82a9f9d7abc9cd010223fa3d70a6526a3f28f8e17d814c06e18f9e.css">

  
  <link rel="stylesheet" href="/css/main.min.1d8be2dd1b5de9fdaed058c8c59fcf4485f36619574abfb47ed0cfda4812c16d.css">

  
  <link rel="stylesheet" href="/css/menu.min.83637a90d903026bc280d3f82f96ceb06c5fc72b7c1a8d686afb5bbf818a29f7.css">

  
  <link rel="stylesheet" href="/css/pagination.min.82f6400eae7c7c6dc3c866733c2ec0579e4089608fea69400ff85b3880aa0d3c.css">

  
  <link rel="stylesheet" href="/css/post.min.fc74ca360273c1d828da3c02b8174eba435607b369d98418ccc6f2243cd4e75d.css">

  
  <link rel="stylesheet" href="/css/prism.min.9023bbc24533d09e97a51a0a42a5a7bfe4c591ae167c5551fb1d2191d11977c0.css">

  
  <link rel="stylesheet" href="/css/syntax.min.cc789ed9377260d7949ea4c18781fc58959a89287210fe4edbff44ebfc1511b6.css">

  
  <link rel="stylesheet" href="/css/terminal.min.07d06f9a9d3c0e8aeceef1aa0e16487bb4dc3d1fc254e66cff25df004ed46ccb.css">

  
  <link rel="stylesheet" href="/css/terms.min.b81791663c3790e738e571cdbf802312390d30e4b1d8dc9d814a5b5454d0ac11.css">







<link rel="shortcut icon" href="/favicon.png">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">


<meta name="twitter:card" content="summary" />

  
    <meta name="twitter:site" content="" />
  
    <meta name="twitter:creator" content="" />



<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="42 команды Linux которые вы должны знать">
<meta property="og:description" content="о всех операционных системах, в том числе и в Linux, термин &lsquo;команда&rsquo; означает либо утилиту командной строки, либо определённую возможность, встроенную в командную оболочку системы. Тем не менее, для самих пользователей это различие не имеет особого значения. В конце концов, и те и другие команды терминала Linux вызываются одинаково. Вы вводите слово в вашем эмуляторе терминала и получаете результат выполнения команды.
Я уже писал о командах терминала Linux, но тогда затронул лишь несколько самых интересных, самых полезных команд, рассчитывая на то, что пользователь уже достаточно знаком с возможностями терминала. Но нужно сделать ещё одну статью, рассчитанную на новичков, тех, кто только делает свои первые шаги в освоении Linux.
" />
<meta property="og:url" content="/posts/42_must_have_commands_linux/" />
<meta property="og:site_name" content="Terminal" />

  
  
  <meta property="og:image" content="/">

<meta property="og:image:width" content="1200">
<meta property="og:image:height" content="627">


  <meta property="article:published_time" content="2024-10-16 14:18:27 &#43;0300 MSK" />












</head>
<body>


<div class="container center">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    ConFet.net
  </div>
</a>

    </div>
    
      <ul class="menu menu--mobile">
  <li class="menu__trigger">Menu&nbsp;▾</li>
  <li>
    <ul class="menu__dropdown">
      
        
          <li><a href="/">Статьи</a></li>
        
      
        
          <li><a href="/news">Новости</a></li>
        
      
        
          <li><a href="/about">О нас</a></li>
        
      
      
    </ul>
  </li>
</ul>

    
    
  </div>
  
    <nav class="navigation-menu">
  <ul class="navigation-menu__inner menu--desktop">
    
      
        
          <li><a href="/" >Статьи</a></li>
        
      
        
          <li><a href="/news" >Новости</a></li>
        
      
        
          <li><a href="/about" >О нас</a></li>
        
      
      
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<article class="post">
  <h1 class="post-title">
    <a href="/posts/42_must_have_commands_linux/">42 команды Linux которые вы должны знать</a>
  </h1>
  <div class="post-meta"><time class="post-date">2024-10-16</time></div>

  
    <span class="post-tags">
      
      #<a href="/tags/"></a>&nbsp;
      
      #<a href="/tags/"></a>&nbsp;
      
    </span>
  
  


  
    <div class="table-of-contents">
      <h2>
        Содержание статьи
      </h2>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#команды-linux-для-управления-файлами">Команды Linux для управления файлами</a>
      <ul>
        <li><a href="#1-ls">1. ls</a></li>
        <li><a href="#2-cat">2. cat</a></li>
        <li><a href="#3-cd">3. cd</a></li>
        <li><a href="#4-pwd">4. pwd</a></li>
        <li><a href="#5-mkdir">5. mkdir</a></li>
        <li><a href="#6-file">6. file</a></li>
        <li><a href="#7-cp">7. cp</a></li>
        <li><a href="#8-mv">8. mv</a></li>
        <li><a href="#9-rm">9. rm</a></li>
        <li><a href="#10-ln">10. ln</a></li>
        <li><a href="#11-chmod">11. chmod</a></li>
        <li><a href="#12-chown">12. chown</a></li>
        <li><a href="#13-find">13. find</a></li>
        <li><a href="#14-locate">14. locate</a></li>
        <li><a href="#15-du">15. du</a></li>
        <li><a href="#16-df">16. df</a></li>
        <li><a href="#17-dd">17. dd</a></li>
        <li><a href="#18-mount--umount">18 mount / umount</a></li>
      </ul>
    </li>
    <li><a href="#linux-команды-консоли-для-работы-с-текстом">Linux команды консоли для работы с текстом</a>
      <ul>
        <li><a href="#19-more--less">19. more / less</a></li>
        <li><a href="#20-head--tail">20. head / tail</a></li>
        <li><a href="#21-grep">21. grep</a></li>
        <li><a href="#22-sort">22. sort</a></li>
        <li><a href="#23-wc">23. wc</a></li>
        <li><a href="#24-diff">24. diff</a></li>
      </ul>
    </li>
    <li><a href="#команды-linux-для-управления-процессами">Команды Linux для управления процессами</a>
      <ul>
        <li><a href="#25-kill--xkill--pkill--killall">25. kill / xkill / pkill / killall</a></li>
        <li><a href="#26-ps--pgrep">26. ps / pgrep</a></li>
        <li><a href="#27-top--htop">27. top / htop</a></li>
        <li><a href="#28-time">28. time</a></li>
      </ul>
    </li>
    <li><a href="#команды-linux-окружения-пользователя">Команды Linux окружения пользователя</a>
      <ul>
        <li><a href="#29-su--sudo">29. su / sudo</a></li>
        <li><a href="#30-date">30. date</a></li>
        <li><a href="#31-alias">31. alias</a></li>
        <li><a href="#32-uname">32. uname</a></li>
        <li><a href="#33-uptime">33. uptime</a></li>
        <li><a href="#34-sleep">34. sleep</a></li>
      </ul>
    </li>
    <li><a href="#команды-linux-для-управления-пользователями">Команды Linux для управления пользователями</a>
      <ul>
        <li><a href="#35-useradd--userdel--usermod">35. useradd / userdel / usermod</a></li>
        <li><a href="#36-passwd">36. passwd</a></li>
      </ul>
    </li>
    <li><a href="#linux-команды-для-просмотра-документации">Linux команды для просмотра документации</a>
      <ul>
        <li><a href="#37-man--whatis">37. man / whatis</a></li>
        <li><a href="#38-whereis">38. whereis</a></li>
      </ul>
    </li>
    <li><a href="#команды-linux-для-управления-сетью">Команды Linux для управления сетью</a>
      <ul>
        <li><a href="#39-ip">39. ip</a></li>
        <li><a href="#40-ping">40. ping</a></li>
        <li><a href="#41-nethogs">41. nethogs</a></li>
        <li><a href="#42-traceroute">42. traceroute</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
  

  <div class="post-content"><div>
        <p>о всех операционных системах, в том числе и в Linux, термин &lsquo;команда&rsquo; означает либо утилиту командной строки, либо определённую возможность, встроенную в командную оболочку системы. Тем не менее, для самих пользователей это различие не имеет особого значения. В конце концов, и те и другие команды терминала Linux вызываются одинаково. Вы вводите слово в вашем эмуляторе терминала и получаете результат выполнения команды.</p>
<p>Я уже писал о командах терминала Linux, но тогда затронул лишь несколько самых интересных, самых полезных команд, рассчитывая на то, что пользователь уже достаточно знаком с возможностями терминала. Но нужно сделать ещё одну статью, рассчитанную на новичков, тех, кто только делает свои первые шаги в освоении Linux.</p>
<p>И вот она. Её цель - собрать основные простые и сложные команды Linux, которые должен знать каждый пользователь, чтобы наиболее эффективно управлять своей системой. Для удобности запоминания опций команд я в скобках добавил слова, от которых они произошли - так намного проще, на себе проверено.</p>
<p>Это не значит, что я перечислю все команды, все перечислены тут - я постараюсь охватить всё самое полезное, то, что может пригодиться в повседневной жизни. Чтобы было удобнее читать, разделим этот список на категории команд по назначению. Большинство рассмотренных здесь утилит не требуют дополнительной установки, они будут предустановлены в любом дистрибутиве Linux, а если не будут, то их несложно найти в официальных репозиториях.</p>
<h2 id="команды-linux-для-управления-файлами">Команды Linux для управления файлами<a href="#команды-linux-для-управления-файлами" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="1-ls">1. ls<a href="#1-ls" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Утилита для просмотра содержимого каталогов. По умолчанию показывает текущий каталог. Если в параметрах указать путь, то она перечислит содержимое конечного каталога. Полезные опции -l (List) и -a (All). Первая форматирует вывод в виде списка с более подробной информацией, а вторая включает показ скрытых файлов.</p>
<h3 id="2-cat">2. cat<a href="#2-cat" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Печатает содержимое файла, переданного в параметре, в стандартный вывод. Если передать несколько файлов, команда склеит их. Также можно перенаправить вывод в ещё один файл с помощью символа &lsquo;&gt;&rsquo;. Если нужно вывести только определенное количество строк, используйте опцию -n (Number).</p>
<h3 id="3-cd">3. cd<a href="#3-cd" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Позволяет перейти из текущего каталога в указанный. Если запустить без параметров - возвращает в домашний каталог. Вызов с двумя точками возвращает на уровень вверх относительно текущего каталога. Вызов с тире (cd -) возвращает к предыдущему каталогу.</p>
<h3 id="4-pwd">4. pwd<a href="#4-pwd" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Печатает на экран текущий каталог. Это может быть полезно, если ваша командная строка Linux не выводит такую информацию. Эта команда будет востребована в Bash программировании, где для получения ссылки на каталог выполняется скрипт.</p>
<h3 id="5-mkdir">5. mkdir<a href="#5-mkdir" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Создание новых каталогов. Наиболее удобная опция -p (Parents), позволяет создать всю структуру подкаталогов одной командой, даже если они ещё не существуют.</p>
<h3 id="6-file">6. file<a href="#6-file" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Команда file показывает тип файла. В Linux файлы не обязаны всегда иметь расширения для того, чтобы с ними работать. Поэтому пользователю иногда трудно определить, что за файл перед ним. Эта маленькая утилита решает проблему.</p>
<h3 id="7-cp">7. cp<a href="#7-cp" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Копирование файлов и каталогов. Она не копирует каталоги по умолчанию рекурсивно (то есть все поддиректории и все файлы в поддиректориях), поэтому не забудьте добавить опцию -r (Recursive) или -a (Archive). Последняя включает режим сохранения атрибутов, владельца и временного штампа в дополнение к рекурсивному копированию.</p>
<h3 id="8-mv">8. mv<a href="#8-mv" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Перемещение или переименование файлов и каталогов. Примечательно, что в Linux это одна и та же операция. Переименование - это перемещение файла в ту же папку с другим именем.</p>
<h3 id="9-rm">9. rm<a href="#9-rm" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Удаляет файлы и папки. Очень полезная команда Linux: с её помощью вы можете убрать весь беспорядок. Если нужно рекурсивное удаление, используйте опцию -r. Однако будьте осторожны: конечно, для того чтобы повредить систему вам нужно будет серьёзно постараться, однако можно удалить собственные важные файлы. Rm удаляет файлы не в корзину, из которой потом всё можно будет восстановить, а полностью стирает. Действия оператора rm необратимы. Поверьте, ваши оправдания в духе &ldquo;rm съела мою курсовую&rdquo; никому не будут интересны.</p>
<h3 id="10-ln">10. ln<a href="#10-ln" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Создает жёсткие или символические ссылки на файлы. Символические или программные ссылки - это что-то похожее на ярлыки в Windows. Они предоставляют удобный способ доступа к определённому файлу. Символические ссылки указывают на файл, но не имеют никаких метаданных. Жёсткие ссылки, в отличие от символических, указывают на физический адрес области диска, где хранятся данные файла.</p>
<h3 id="11-chmod">11. chmod<a href="#11-chmod" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Изменяет права доступа к файлу. Это чтение, запись и выполнение. Каждый пользователь может изменять права для своих файлов.</p>
<h3 id="12-chown">12. chown<a href="#12-chown" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Изменяет владельца файла. Только суперпользователь может изменять владельцев. Для рекурсивного изменения используйте опцию -R.</p>
<h3 id="13-find">13. find<a href="#13-find" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Поиск в файловой системе, файлах и папках. Это очень гибкая и мощная команда Linux не только из-за своих способностей ищейки, но и благодаря возможности выполнять произвольные команды для найденных файлов.</p>
<h3 id="14-locate">14. locate<a href="#14-locate" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>В отличие от find, команда locate ведёт поиск в базе данных updatedb для шаблонов имён файлов. Эта база данных содержит снимок файловой системы, что позволяет искать очень быстро. Но этот поиск ненадёжен, потому что вы не можете быть уверены, что ничего не изменилось с момента последнего снимка.</p>
<h3 id="15-du">15. du<a href="#15-du" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Показывает размер файла или каталога. Самые полезные опций: -h (Human), которая преобразует размеры файлов в легко читаемый формат, -s (Summarize), которая выводит минимум данных, и -d (Depth), устанавливающая глубину рекурсии по каталогам.</p>
<h3 id="16-df">16. df<a href="#16-df" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Анализатор дискового пространства. По умолчанию вывод достаточно подробный: перечислены все файловые системы, их размер, количество использованного и свободного пространства. Для удобства есть опция -h, делающая размеры легко читаемыми.</p>
<h3 id="17-dd">17. dd<a href="#17-dd" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Как сказано в официальном руководстве, это команда терминала для копирования и преобразования файлов. Не очень понятное описание, но это всё, что делает dd. Вы передаёте ей файл-источник, пункт назначения и пару дополнительных опций. Затем она делает копию одного файла в другой. Вы можете задать точный размер данных, которые нужно записать или скопировать. Работает утилита со всеми устройствами. Например, если вы хотите перезаписать жёсткий диск нулями из /dev/zero, можете сделать это. Также она часто используется для создания LiveUSB или гибридных ISO образов.</p>
<h3 id="18-mount--umount">18 mount / umount<a href="#18-mount--umount" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Это команды консоли Linux для подключения и отключения файловых систем Linux. Можно подключать всё: от USB накопителей, до ISO образов. И только у суперпользователя есть права для этого.</p>
<h2 id="linux-команды-консоли-для-работы-с-текстом">Linux команды консоли для работы с текстом<a href="#linux-команды-консоли-для-работы-с-текстом" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="19-more--less">19. more / less<a href="#19-more--less" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Это две простенькие команды терминала для просмотра длинных текстов, которые не вмещаются на одном экране. Представьте себе очень длинный вывод команды. Или вы вызвали cat для просмотра файла, и вашему эмулятору терминала потребовалось несколько секунд, чтобы прокрутить весь текст. Если ваш терминал не поддерживает прокрутки, вы можете сделать это с помощью less. Less новее, чем more и поддерживает больше опций, поэтому использовать more нет причин.</p>
<h3 id="20-head--tail">20. head / tail<a href="#20-head--tail" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Ещё одна пара, но здесь у каждой команды своя область применения. Утилита head выводит несколько первых строк из файла (голова), а tail выдает несколько последних строк (хвост). По умолчанию каждая утилита выводит десять строк. Но это можно изменить с помощью опции -n. Ещё один полезный параметр -f, это сокращение от follow (следовать). Утилита постоянно выводит изменения в файле на экран. Например, если вы хотите следить за лог файлом, вместо того, чтобы постоянно открывать и закрывать его, используйте команду tail -nf.</p>
<h3 id="21-grep">21. grep<a href="#21-grep" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Grep, как и другие инструменты Linux, делает одно действие, но делает его хорошо: она ищет текст по шаблону. По умолчанию она принимает стандартный ввод, но вы можете искать в файлах. Шаблон может быть строкой или регулярным выражением. Она может вывести как совпадающие, так и не совпадающие строки и их контекст. Каждый раз, когда вы выполняете команду, которая выдает очень много информации, не нужно анализировать всё вручную - пусть grep делает свою магию.</p>
<h3 id="22-sort">22. sort<a href="#22-sort" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Сортировка строк текста по различным критериям. Наиболее полезные опции: -n (Numeric), по числовому значению, и -r (Reverse), которая переворачивает вывод. Это может быть полезно для сортировки вывода du. Например, если хотите отсортировать файлы по размеру, просто соедините эти команды.</p>
<h3 id="23-wc">23. wc<a href="#23-wc" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Утилита командной строки Linux для подсчёта количества слов, строк, байт и символов.</p>
<h3 id="24-diff">24. diff<a href="#24-diff" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Показывает различия между двумя файлами в построчном сравнении. Причём выводятся только строки, в которых обнаружены отличия. Измененные строки отмечаются символом &ldquo;с&rdquo;, удаленные - &ldquo;d&rdquo;, а новые - &ldquo;а&rdquo;.</p>
<p>Кстати, я подготовил ещё одну подробную статью, в которой описан именно просмотр содержимого текстового файла в Linux c помощью терминала.</p>
<h2 id="команды-linux-для-управления-процессами">Команды Linux для управления процессами<a href="#команды-linux-для-управления-процессами" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="25-kill--xkill--pkill--killall">25. kill / xkill / pkill / killall<a href="#25-kill--xkill--pkill--killall" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Служат для завершения процессов. Но они принимают различные параметры для идентификации процессов. Kill нужен PID процесса, xkill - достаточно кликнуть по окну, чтобы закрыть его, killall и pkill принимают имя процесса. Используйте ту, которая удобна в определенной ситуации.</p>
<h3 id="26-ps--pgrep">26. ps / pgrep<a href="#26-ps--pgrep" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Как уже говорилось, чтобы уничтожить процесс, нужен его идентификатор. Один из способов получить его, это утилита ps, которая печатает информацию о запущенных процессах. По умолчанию вывод очень длинный, поэтому используйте опцию -e, чтобы увидеть информацию об определённом процессе. Это только снимок состояния на момент вызова, и информация не будет обновляться. Команда ps с ключом aux выводит полную информацию о процессах. Pgrep работает следующим образом: вы задаете имя процесса, а утилита показывает его идентификатор.</p>
<h3 id="27-top--htop">27. top / htop<a href="#27-top--htop" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Обе команды похожи, обе отображают процессы и могут быть использованы как консольные системные мониторы. Я рекомендую установить htop, если в вашем дистрибутиве он не поставляется по умолчанию, так как это улучшенная версия top. Вы сможете не только просматривать, но и контролировать процессы через его интерактивный интерфейс.</p>
<h3 id="28-time">28. time<a href="#28-time" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Время выполнения процесса. Это секундомер для выполнения программы. Полезно, если вам интересно, насколько сильно ваша реализация алгоритма отстает от стандартной. Но, несмотря на такое название, она не сообщит вам текущее время, используйте для этого команду date.</p>
<h2 id="команды-linux-окружения-пользователя">Команды Linux окружения пользователя<a href="#команды-linux-окружения-пользователя" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="29-su--sudo">29. su / sudo<a href="#29-su--sudo" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Su и sudo - это два способа выполнить одну и ту же задачу: запустить программу от имени другого пользователя. В зависимости от вашего дистрибутива вы, наверное, используете одну или другую. Но работают обе. Разница в том, что su переключает вас на другого пользователя, а sudo только выполняет команду от его имени. Поэтому использование sudo будет наиболее безопасным вариантом работы. Я писал про права суперпользователя в этой статье.</p>
<h3 id="30-date">30. date<a href="#30-date" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>В отличие от time, делает именно то, чего вы от неё и ожидаете: выводит дату и время в стандартный вывод. Его можно форматировать в зависимости от ваших потребностей: вывести год, месяц, день, установить 12-ти или 24-ти часовой формат, получить наносекунды или номер недели. Например, date +&quot;%j %V&quot;, выведет день в году и номер недели в формате ISO.</p>
<h3 id="31-alias">31. alias<a href="#31-alias" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Команда создаёт синонимы для других команд Linux. То есть вы можете делать новые команды или группы команд, а также переименовывать существующие. Это очень удобно для сокращения длинных команд, которые вы часто используете, или создания более понятных имен для команд, которые вы используете нечасто и не можете запомнить. Здесь собрано несколько полезных алиасов.</p>
<h3 id="32-uname">32. uname<a href="#32-uname" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Выводит некую основную информацию о системе. Без параметров она не покажет ничего полезного, кроме строчки Linux, но, если задать параметр -a (All), можно получить информацию о ядре, имени хоста и узнать архитектуру процессора.</p>
<h3 id="33-uptime">33. uptime<a href="#33-uptime" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Сообщает вам время работы системы. Не очень существенная информация, но может быть полезна для случайных вычислений или просто ради интереса, чтобы узнать, как давно был перезагружен сервер.</p>
<h3 id="34-sleep">34. sleep<a href="#34-sleep" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Вам, наверное, интересно как же её можно использовать. Даже не учитывая Bash-скриптинг, у неё есть свои преимущества. Например, если вы хотите выключить компьютер через определенный промежуток времени или использовать в качестве импровизированной тревоги.</p>
<h2 id="команды-linux-для-управления-пользователями">Команды Linux для управления пользователями<a href="#команды-linux-для-управления-пользователями" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="35-useradd--userdel--usermod">35. useradd / userdel / usermod<a href="#35-useradd--userdel--usermod" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Эти команды консоли Linux позволяют вам добавлять, удалять и изменять учетные записи пользователей. Скорее всего, вы не будете использовать их очень часто. Особенно если это домашний компьютер, и вы являетесь единственным пользователем. Управлять пользователями можно и с помощью графического интерфейса, но лучше знать об этих командах на всякий случай.</p>
<h3 id="36-passwd">36. passwd<a href="#36-passwd" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Эта команда позволяет изменить пароль учетной записи пользователя. Как суперпользователь вы можете сбросить пароли всех пользователей, даже несмотря на то, что не можете их увидеть. Хорошая практика безопасности - менять пароль почаще.</p>
<h2 id="linux-команды-для-просмотра-документации">Linux команды для просмотра документации<a href="#linux-команды-для-просмотра-документации" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="37-man--whatis">37. man / whatis<a href="#37-man--whatis" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Команда man открывает руководство по определённой команде. Для всех основных команд Linux есть man страницы. Whatis показывает, какие разделы руководств есть для данной команды.</p>
<h3 id="38-whereis">38. whereis<a href="#38-whereis" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Показывает полный путь к исполняемому файлу программы. Также может показать путь к исходникам, если они есть в системе.</p>
<h2 id="команды-linux-для-управления-сетью">Команды Linux для управления сетью<a href="#команды-linux-для-управления-сетью" class="hanchor" ariaLabel="Anchor">#</a> </h2>
<h3 id="39-ip">39. ip<a href="#39-ip" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Если список команд Linux для управления сетью вам кажется слишком коротким, скорее всего вы не знакомы с утилитой ip. В пакете net-tools содержится множество других утилит: ipconfig, netstat и прочие устаревшие, вроде iproute2. Всё это заменяет одна утилита - ip. Вы можете рассматривать её как швейцарский армейский нож для работы с сетью или как непонятную массу, но в любом случае за ней будущее. Просто смиритесь с этим.</p>
<h3 id="40-ping">40. ping<a href="#40-ping" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Ping - это ICMP ECHO_REQUEST дейтаграммы, но на самом деле это неважно. Важно то, что утилита ping может быть очень полезным диагностическим инструментом. Она поможет быстро проверить, подключены ли вы к маршрутизатору или к интернету, и дает кое-какое представление о качестве этой связи.</p>
<h3 id="41-nethogs">41. nethogs<a href="#41-nethogs" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Если у вас медленный интернет, то вам, наверное, было бы интересно знать, сколько трафика использует какая-либо программа в Linux или какая программа потребляет всю скорость. Теперь это можно сделать с помощью утилиты nethogs. Для того чтобы задать сетевой интерфейс используйте опцию -i.</p>
<h3 id="42-traceroute">42. traceroute<a href="#42-traceroute" class="hanchor" ariaLabel="Anchor">#</a> </h3>
<p>Это усовершенствованная версия ping. Мы можем увидеть не только полный маршрут сетевых пакетов, но и доступность узла, а также время доставки этих пакетов на каждый из узлов.</p>

      </div></div>

  
    
<div class="pagination">
  <div class="pagination__title">
    <span class="pagination__title-h">Другие посты</span>
    <hr />
  </div>
  <div class="pagination__buttons">
    
    
    
      <a href="/posts/installing_certificates_ubuntu/" class="button inline next">
        Установка сертификатов в Ubuntu
      </a>
    
  </div>
</div>


  

  
    

  
</article>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
      <div class="copyright">
        <span>© 2024 Made with Love</span>
    
      </div>
  </div>
</footer>






<script type="text/javascript" src="/bundle.min.js"></script>





  
</div>

</body>
</html>
